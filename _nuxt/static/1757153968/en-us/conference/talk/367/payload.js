__NUXT_JSONP__("/en-us/conference/talk/367", (function(a,b){b.id=367;b.begin_time="2025-09-07T05:20:00Z";b.end_time="2025-09-07T05:50:00Z";b.is_remote=false;b.location="6-r2";b.youtube_id=a;b.title="從 Closure 到 Late Binding：Python 變數作用域與執行行為探討";b.category="CORE";b.language="ZHZH";b.python_level="INTERMEDIATE";b.recording_policy=true;b.abstract="Python 的 list comprehension 結合 lambda 表達式雖然寫法簡潔，卻容易造成變數綁定上的誤解。\r\n以下面程式為例，其輸出結果並不像直覺上那麼簡單：\r\nlst = [lambda: i for i in range(5)]\r\n \r\n本次將依據 PEP 227 規範，深入解析 Python 變數作用域及記憶體管理的運作原理。並設計實驗驗證 CPython 的實際行為確實遵循規範且可被觀察重現。";b.detailed_description="本議程將以實際開發中遇到的 Late Binding 問題為切入點，從 Python Lambda 函式的 Closure 特性出發，深入探討 Python 變數作用域及底層行為。\r\n首先，我們將分析該問題的發生原因，並引入官方規範 PEP 227，說明 Python 對閉包與自由變數的設計原則，如何影響變數在不同作用域中的綁定與存活時間。\r\n接著，透過精心設計的實驗，我們將驗證 CPython 實際執行時的行為，確認其符合 PEP 規範且結果具備可觀察性與可重現性。\r\n最後，藉由這些深入剖析與實證，協助開發者釐清常見誤解，掌握變數綁定的本質，避免在使用 lambda 與閉包時重複踩雷，提升程式設計的正確性與穩定性。\r\n面對資訊爆炸與 AI 內容充斥的時代，更應依循官方文件與規範，建立紮實且正確的技術理解。";b.slide_link=a;b.slido_embed_link="https:\u002F\u002Fapp.sli.do\u002Fevent\u002Fba7VNGhbpjEiM221UPgVaN";b.hackmd_embed_link="https:\u002F\u002Fhackmd.io\u002F@pycontw\u002FH1tQRnuYgg";b.speakers=[{thumbnail_url:"https:\u002F\u002Ftw.pycon.org\u002Fprs\u002Fmedia\u002Fcache\u002F43\u002F99\u002F4399afd2f6138d860975dfe0c0f9c6da.jpg",name:"曾昱翔",github_profile_url:"https:\u002F\u002Fgithub.com\u002Fasas1asas200",twitter_profile_url:a,facebook_profile_url:a,bio:"A software engineer and an Arch Linux enthusiast.\r\nWith years of experience working closely with open-source systems, he is passionate about building efficient, customizable solutions that put the user in control."}];b.event_type="talk";return {data:[{speechData:b}],fetch:{},mutations:[["setSpeechData",b]]}}("",{})));