__NUXT_JSONP__("/en-us/conference/talk/347", (function(a,b){b.id=347;b.begin_time="2025-09-07T06:00:00Z";b.end_time="2025-09-07T06:30:00Z";b.is_remote=false;b.location="5-r1";b.youtube_id=a;b.title="From autocorrelation to unsupervised learning; searching for aperiodic tilings (quasicrystals) in images via patch-hashing.";b.category="DATA";b.language="ENEN";b.python_level="INTERMEDIATE";b.recording_policy=true;b.abstract="\"Arguably much of the understanding of the world around us is based on the perception and recognition of shared or repeated structures, and so is our sense of beauty [Thompson 1961]\"\r\n\r\nI'll explain step-by-step how we started by identifying repeated patterns as patches in images by eye, then searching for similar instances via mathematical correlation, then, to avoid strong human bias we moved to autocorrelation, incorporating rotation and mirroring degrees of freedom, using Python and numba (@jit). I'll then explain how we moved to standard forms of unsupervised machine learning with rotation and reflection invariance so that we could expand our search to a larger and more diverse database of (Physics STM) images. I will cover in detail how, using Python, we implemented patch searching, image hashing using discrete cosine transforms, then finally geometrical hashing based on positions of atoms and clusters.\r\n\r\nTHOMPSON, D. W. 1961. On Growth and Form. Cambridge.";b.detailed_description="Scanning Tunneling Microscopy (STM) images contain a wealth of data on the arrangements and patterns of atoms on surfaces. This is useful for both basic science and for building new, high-technology two dimensional (2D) materials and heterostructures for next-generation electronics and nanomaterials. One project we are working on is the detection of long-range order in superficially \"chaotic\" atomic arrangements with strong Fourier transform components (2D quasicrystal) and higher order coincident (HOC) arrangements. \r\n\r\nTo this end we have developed various techniques, from kernel (image patch) correlation to autocorrelation that work on these notoriously noisy images with stubborn artifacts. But we wanted to go further, searching a larger library of images for more patterns, and remove the human element for scientific objectivity. So we decided to apply unsupervised machine learning. To keep the data size manageable, images need to be broken down to smaller elements and these often need to be further \"hashed\" into a handful of numbers, representing either discrete cosine transform coefficients, or small spatial relationships of predefined features, which in our case are individual atoms and the \"holes\" - centers of the 5, 6, and 7 atom rings of atoms.\r\n\r\nWhile our application was specific, there is no difference between seeking repeated instances of the \"bumblebee\" and \"butterfly\" shaped atomic clusters in our data, and seeking instances of cats, dogs, or human faces in real world media. Thus the python implementation and package usage I'll discuss is just as relevant to the general ML community as it is to surface scientists.";b.slide_link=a;b.slido_embed_link="https:\u002F\u002Fapp.sli.do\u002Fevent\u002FrLwKkQnELwdrU59SgZWFC8";b.hackmd_embed_link=a;b.speakers=[{thumbnail_url:"https:\u002F\u002Ftw.pycon.org\u002Fprs\u002Fmedia\u002Fcache\u002F28\u002F1d\u002F281da5e8ee4e0d4747763e13ded43adc.jpg",name:"David Mikolas",github_profile_url:a,twitter_profile_url:a,facebook_profile_url:a,bio:"BS. Astronomy, Ph.D. Nuclear Physics, then some nanofabrication and then some fiber optics, then on to semiconductor process development and then critical dimension and thin film crystallographic texture metrology, now back to Physics, surface science, 2D materials and electron diffraction metrology.\r\n\r\nCurrently I work as a postdoc in the NTHU department of Physics. https:\u002F\u002Fsites.google.com\u002Fview\u002Fsjt-surfacescience\u002F We study new 2D materials - their properties and how to make them. Would you like to join us?"}];b.event_type="talk";return {data:[{speechData:b}],fetch:{},mutations:[["setSpeechData",b]]}}("",{})));